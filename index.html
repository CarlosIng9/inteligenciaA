<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INTELIGENCIA ARTIFICIAL</title>
    <!-- Incluir CSS de Bootstrap -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <div class="container">
        <!-- Encabezado principal -->
        <h1 class="my-4 text-center">INTELIGENCIA ARTIFICIAL</h1>

        <!-- Botones de navegación -->
        <div class="btn-navigate">
            <a href="#inteligencia-artificial" class="btn-custom">Inteligencia Artificial</a>
            <a href="#actividades" class="btn-custom">Actividades Similares</a>
            <a href="#aprendizaje" class="btn-custom">Aprendizaje</a>
            <a href="#red-neuronal" class="btn-custom">Red Neuronal</a>
            <a href="#parcial-2" class="btn-custom">Parcial 2</a>
        </div>

        <!-- Sección Inteligencia Artificial -->
        <h2 id="inteligencia-artificial">Inteligencia Artificial</h2>
        <p class="lead">He aprendido sobre algunos nombres de IA, normalizando todos los datos en Excel utilizando ETL
            para la transformación de datos.</p>

        <!-- Sección Actividades Similares -->
        <h2 id="actividades">Actividades Similares</h2>
        <div class="row">
            <div class="col-md-4 mb-4">
                <div class="card">
                    <img src="1.jpeg" alt="Gráfico de pastel mostrando datos repetidos"
                        class="img-custom-size card-img-top">
                    <div class="card-body">
                        <p class="card-text">Vimos qué datos se repetían y los graficamos en una gráfica de pastel.</p>
                    </div>
                </div>
            </div>
            <div class="col-md-4 mb-4">
                <div class="card">
                    <img src="2.jpeg" alt="Agrupación manual de actividades similares"
                        class="img-custom-size card-img-top">
                    <div class="card-body">
                        <p class="card-text">Agrupamos manualmente actividades similares y las contamos.</p>
                    </div>
                </div>
            </div>
            <div class="col-md-4 mb-4">
                <div class="card">
                    <img src="3.jpeg" alt="Análisis de palabras repetidas y únicas con gráficos circulares 3D"
                        class="img-custom-size card-img-top">
                    <div class="card-body">
                        <p class="card-text">Elegimos palabras repetidas de la columna 5 con la ayuda de ChatGPT y las
                            verificamos manualmente.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sección Aprendizaje -->
        <h2 id="aprendizaje">CLASE 22 DE AGOSTO, APRENDIZAJE</h2>
        <p>En esta clase aprendimos sobre los porcentajes de evaluación y cómo la inteligencia artificial se basa en la
            forma en que los humanos resolvemos tareas diarias.</p>

        <!-- Sección Red Neuronal -->
        <h2 id="red-neuronal">CLASE 29 DE AGOSTO, REDES NEURONALES</h2>
        <h3>¿QUÉ ES RED NEURONAL?</h3>
        <p>Una red neuronal es un modelo computacional inspirado en el cerebro humano. Se usa para problemas complejos
            que requieren reconocimiento de patrones.</p>

        <div class="card my-4">
            <img src="5.png" alt="RED NEURONAL" class="img-custom-size card-img-top">
            <div class="card-body">
                <p class="card-text">Las redes neuronales profundas son clave en el reconocimiento de voz y visión por
                    computadora.</p>
            </div>
        </div>

        <!-- Ejemplo práctico en Google Colab -->
        <h2>CLASE 12 DE SEPTIEMBRE, EJEMPLO PRÁCTICO EN GOOGLE COLAB</h2>
        <p>En esta clase trabajamos con redes neuronales en Google Colab, utilizando Python.</p>

        <div class="card my-4">
            <img src="CONVERSION.PNG" alt="Gráfica de entrenamiento de red neuronal"
                class="img-custom-size card-img-top">
            <div class="card-body">
                <p class="card-text">Gráfica obtenida del entrenamiento de la red neuronal.</p>
            </div>
        </div>

        <!-- Tabla de comparación de laberintos -->
        <h2>Comparación de Resultados de Laberintos</h2>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Laberinto</th>
                    <th>Algoritmo</th>
                    <th>Estados Explorados</th>
                    <th>Imagen</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Laberinto Grupo A</td>
                    <td>BFS</td>
                    <td>331</td>
                    <td><img src="LABERINTO GRUPO A BFS.png" alt="Laberinto Grupo A BFS" class="img-custom-size"></td>
                </tr>
                <tr>
                    <td>Laberinto Grupo B</td>
                    <td>BFS</td>
                    <td>319</td>
                    <td><img src="LABERINTO GRUPO B BFS.png" alt="Laberinto Grupo B BFS" class="img-custom-size"></td>
                </tr>
                <tr>
                    <td>Laberinto Grupo A</td>
                    <td>DFS</td>
                    <td>227</td>
                    <td><img src="LABERINTO GRUPO A DFS.png" alt="Laberinto Grupo A DFS" class="img-custom-size"></td>
                </tr>
                <tr>
                    <td>Laberinto Grupo B</td>
                    <td>DFS</td>
                    <td>265</td>
                    <td><img src="LABERINTO GRUPO B DFS.png" alt="Laberinto Grupo B DFS" class="img-custom-size"></td>
                </tr>
            </tbody>
        </table>

        <div class="container mt-5">
            <h1>EXPLICACIÓN POR QUE GANA LA COMPUTADORA</h1>
            <p>
                .Descripción general
                El código permite a dos jugadores (HUMANO y COMPUTADORA) turnarse para hacer movimientos en un tablero
                de 3x3, representado como una matriz.
                El objetivo del juego es que uno de los jugadores logre alinear tres de sus fichas (ya sea en una fila,
                columna o diagonal), lo que se define
                como una condición de victoria. La computadora, al ser controlada por el código, usa el algoritmo
                Minimax para calcular sus movimientos, asegurándose
                de maximizar sus oportunidades de ganar y minimizar las posibilidades de que el jugador humano lo haga.

                .Funciones principales
                Constantes de jugadores:
                HUMANO = -1 y COMPUTADORA = 1 son las constantes que representan a los jugadores en el tablero. La
                computadora se representa por "1" y el humano por "-1",
                mientras que las posiciones vacías se representan con "0".

                ganador(tablero, jugador): Esta función verifica si el jugador dado ha ganado el juego. Para ello,
                compara el estado actual del tablero con una serie de posibles
                combinaciones ganadoras (filas, columnas y diagonales). Si alguna combinación coincide con tres fichas
                del mismo jugador, la función devuelve True, indicando
                que ese jugador ha ganado.

                tablero_lleno(tablero): Esta función recorre el tablero y verifica si ya no quedan movimientos posibles,
                es decir, si todas las casillas están ocupadas. Devuelve True
                si el tablero está lleno y False si aún quedan espacios vacíos.

                evaluar(tablero): Evalúa el estado del juego. Si la computadora ha ganado, devuelve 1. Si ha ganado el
                humano, devuelve -1. Si no hay ganador, devuelve 0. Esta función
                se usa como criterio en el algoritmo Minimax para decidir el mejor movimiento.

                minimax(tablero, profundidad, jugador): Esta es la implementación del algoritmo Minimax. El algoritmo
                simula todas las posibles jugadas futuras para encontrar la mejor
                jugada que maximice las posibilidades de la computadora de ganar o minimizar las del oponente (humano).
                El algoritmo recorre todas las posiciones posibles en
                el tablero. Si es el turno de la computadora, busca maximizar el valor (mejorar sus chances); si es el
                turno del humano, intenta minimizarlo
                (para evitar que la computadora gane).

                movimiento_computadora(tablero): Usa el algoritmo Minimax para determinar el mejor movimiento para la
                computadora. Recorre todas las posiciones vacías en el tablero,
                simula las jugadas posibles utilizando Minimax, y selecciona la posición que maximice las posibilidades
                de la computadora de ganar.

                imprimir_tablero(tablero): Esta función imprime el estado actual del tablero en la consola. Cada fila
                del tablero se imprime como una lista, permitiendo que el jugador
                humano vea el estado del juego después de cada turno.

                juego(): La función principal del programa, que simula el desarrollo completo del juego. Dentro de un
                bucle infinito, alterna entre el turno del humano y el de la
                computadora hasta que se cumpla alguna de las siguientes condiciones:
                Alguien gana (humano o computadora).
                El tablero está lleno, lo que implica un empate.

                .Flujo del programa
                El tablero se inicializa vacío y el juego comienza.
                El humano ingresa su movimiento (fila y columna). Si el movimiento es válido (la casilla está vacía), se
                actualiza el tablero.
                Se verifica si el humano ha ganado. Si es así, se muestra un mensaje y el juego termina.
                Si no hay ganador, la computadora realiza su movimiento calculado por Minimax.
                Se verifica si la computadora ha ganado. Si es así, se muestra un mensaje y el juego termina.
                Si no hay ganador y el tablero no está lleno, el ciclo se repite.
            </p>
        </div>

        <h2>ENCUESTA Y PROFESION OBTENIDA</h2>
        <p>En esta clase se realizo encuesta para describir nuestro perfil y ver profesiones que podriamos ejercer de
            acuerdo a nuestro perfil:</p>

        <div class="card my-4">
            <img src="ENCUESTA 1.PNG" alt="ENCUESTA 1" class="img-custom-size card-img-top">
            <div class="card-body">
                <p class="card-text">ENCUESTA 1, RESULTADOS OBTENIDOS.</p>
            </div>
        </div>

        <p>Aqui observamos el resultado de la segunda encuesta, donde escogi la zona de trabajo 3:</p>

        <div class="card my-4">
            <img src="ENCUESTA 2.PNG" alt="ENCUESTA 2" class="img-custom-size card-img-top">
            <div class="card-body">
                <p class="card-text">ENCUESTA 2, RESULTADOS OBTENIDOS.</p>
            </div>
        </div>

        <p>Aqui observamos que me recomiendan la profesion de ingeniero automatizador de pruebas: </p>

        <div class="card my-4">
            <img src="encuesta 2.1.PNG" alt="ENCUESTA 2.1" class="img-custom-size card-img-top">
            <div class="card-body">
                <p class="card-text">PROFESION RECOMENDADA</p>
            </div>
        </div>

        <p>Por ultimo obtenemos el perfil de interes ONET: </p>

        <div class="card my-4">
            <img src="ENCUESTA 3.PNG" alt="ENCUESTA 3" class="img-custom-size card-img-top">
            <div class="card-body">
                <p class="card-text">PERFIL ONET OBTENIDO</p>
            </div>

            <p>A CONTINUACION ANEXO LOS ARCHIVOS PDF DE MI CARRERA RECOMENDADA Y DEL RESULTADO DE LA ENCUESTA #2 DE LA
                OTRA PAGINA:</p>

            <a href="ingeniero.pdf" target="_blank" class="btn btn-primary">Acceder a PDF profesion recomendada</a>
            <br>
            <br>
            <a href="TRABAJO.pdf" target="_blank" class="btn btn-primary">Acceder a PDF listado de carreras</a>
        </div>

        <div class="container mt-5">
            <h2 class="text-center mb-4" id="parcial-2">PARCIAL 2: INTELIGENCIA ARTIFICIAL</h2>

            <h3>Introducción a la Lógica Proposicional y Model Checking</h3>
            <p>
                En este documento vamos a explorar cómo la lógica proposicional y el model checking pueden ser
                utilizados para
                realizar inferencias lógicas. Nos basaremos en dos ejemplos de código que ilustran cómo construir y
                consultar
                una base de conocimientos en Python utilizando estructuras lógicas como símbolos, implicaciones y
                conectivos lógicos.
            </p>

            <p>
                En estos ejemplos, abordamos situaciones relacionadas con la inferencia lógica a partir de un conjunto
                de
                proposiciones. Usamos un sistema en el cual definimos hechos y reglas, y posteriormente verificamos qué
                conclusiones pueden derivarse de la base de conocimiento, empleando un proceso conocido como "model
                checking".
            </p>

            <h4>Ejemplo original: Caso de los estudiantes y la lluvia</h4>
            <p>
                El primer ejemplo se basa en la siguiente situación:
            </p>

            <h5>Escenario:</h5>
            <ul>
                <li>Si no llueve, los estudiantes visitan BBC hoy.</li>
                <li>Los estudiantes visitaron BBC o Unimayor, pero no ambos.</li>
                <li>Se sabe que los estudiantes visitaron Unimayor hoy.</li>
            </ul>

            <p>
                Con este conjunto de proposiciones, podemos hacernos preguntas como:
            </p>

            <ul>
                <li>¿Qué podemos inferir acerca de BBC?</li>
                <li>¿Qué podemos inferir acerca del clima (si llovió o no)?</li>
            </ul>

            <p>
                En términos de lógica proposicional, esto se puede representar usando símbolos lógicos y expresiones. El
                código
                original utiliza una serie de símbolos (rain, bbc, unimayor) y los combina con conectivos lógicos como
                la
                implicación (Implication), la conjunción (And), la disyunción (Or) y la negación (Not). Posteriormente,
                se
                realiza una verificación mediante la función model_check, que evalúa todos los posibles modelos de
                verdad y determina si
                la consulta es verdadera o falsa según la base de conocimientos.
            </p>

            <p>
                Este código ilustra cómo una base de conocimiento estructurada nos permite responder preguntas sobre
                situaciones
                lógicas complejas de manera formal y precisa.
            </p>

            <h4>Ejemplo mejorado: Refinando el proceso de inferencia</h4>
            <p>
                El código mejorado parte de la misma situación, pero se organiza de manera más clara y funcional. Además
                de los
                comentarios detallados, se añadió una función específica para gestionar las inferencias y presentarlas
                de manera
                más comprensible para el usuario.
            </p>

            <p>
                En esta versión, las inferencias sobre si los estudiantes visitaron BBC y si llovió hoy se realizan de
                manera
                más clara. Las respuestas ahora se presentan de forma explícita, lo que facilita el entendimiento del
                resultado del
                proceso de inferencia.
            </p>

            <h5>Elementos clave del código mejorado:</h5>
            <ul>
                <li><strong>Separación de lógica e inferencias:</strong> Se organiza la lógica de la base de
                    conocimiento de manera independiente de las consultas, lo que mejora la legibilidad y la facilidad
                    de uso.</li>
                <li><strong>Función inferencias():</strong> Se crea una función dedicada a realizar y mostrar las
                    consultas, lo que permite ejecutar todas las inferencias en una sola llamada.</li>
                <li><strong>Claridad en los resultados:</strong> Se mejoró la presentación de las conclusiones,
                    brindando respuestas explícitas (por ejemplo, "Sí, llovió hoy" o "No, no visitaron BBC"), lo que
                    mejora la interpretación de los resultados.</li>
            </ul>

            <p>
                Ambos ejemplos destacan la importancia de representar correctamente la información lógica y cómo la
                inferencia
                sobre modelos de verdad puede darnos respuestas válidas a preguntas complejas, siempre y cuando las
                reglas y hechos
                estén bien estructurados.
            </p>

            <h3>Enlaces adicionales</h3>
            <p>
                A continuación, anexo el link de una carpeta en Drive para observar el código del punto 5 del parcial
                donde se
                comentó cada funcionamiento, dando una breve explicación de su funcionamiento. También se anexa el
                código del
                punto 6 del parcial donde se creó la lógica para verificar la proposición de que si llovió en la
                situación de
                BBC:
            </p>

            <a href="https://drive.google.com/drive/folders/1wG35OJXjZpoySrZfOziJGaHi0NcHmmVO?usp=sharing"
                target="_blank" class="btn btn-primary">Acceder a la carpeta en Google Drive</a>
        </div>

    </div>

    <!-- Incluir JavaScript de Bootstrap y dependencias -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>

</html>